control = rpart.control(minsplit = 10,
minbucket = 5,
maxdepth = 4))
summary(mod.rpart)
rpart.plot(mod.rpart)
pred.prob <- predict(mod.rpart,newdata=testowane)
pred.prob[10:20]
pred.class <- predict(mod.rpart, newdata = testowane, type = "class")
pred.class
tab <- table(predykcja = pred.class, obserwacja = testowane$ChorobaSerca)
tab
sum(diag(tab)/sum(tab))
ggplot(data = as.data.frame(tab), aes(y = predykcja, x = obserwacja, fill = Freq)) +
geom_tile() +
geom_text(aes(label = Freq),size=10,color="black") +
scale_fill_gradient(low = "white", high = "red") +
labs(title = "Macierz Pomyłek",  x = "Prawdziwa klasa", y = "Przewidywana klasa") +
theme_bw()
# Tworzenie obiektu "prediction"
pred <- prediction(pred.prob[,2], testowane$ChorobaSerca)
fig.dim=c(30,20)
plot(perf,col="blue")
plot(perf_log,add=TRUE,col="green")
# Chunk 1: setup
knitr::opts_chunk$set(echo = F, message = F, warning = F)
# Chunk 2
library(tidyverse)
library(ggplot2)
library(rio)
library(PerformanceAnalytics)
library(tidymodels)
library(class)
library(pROC)
library(ISLR)
library(rpart)
library(rpart.plot)
library(caret)
library(kableExtra)
library(reshape)
library(ROCR)
library(tidymodels)
library(randomForest)
library(caTools)
library(e1071)
library(MASS)
# Chunk 3
dane <- read.csv("C:\\Users\\48502\\Desktop\\Baza\\IAD6Sem\\EksploracjaDanych\\Projekt\\heart.csv")
head(dane)
colnames(dane) <- c("Wiek","Plec","Typ_bólu","Ciśnienie_krwi","Cholesterol","Cukier",
"Wynik_EKG","Tętno","Dławica_Piersiowa","spadek_odcinka_ST",
"nachylenie","Liczba_Naczyń","defekt","ChorobaSerca")
head(dane)
str(dane)
summary(dane)
dane$Plec <- factor(dane$Plec)
dane$Typ_bólu <- factor(dane$Typ_bólu)
dane$Wynik_EKG <- factor(dane$Wynik_EKG)
dane$Dławica_Piersiowa <- factor(dane$Dławica_Piersiowa)
dane$nachylenie <- factor(dane$nachylenie)
dane$defekt <- factor(dane$defekt)
dane$ChorobaSerca <- as.factor(dane$ChorobaSerca)
# Chunk 4
dane %>%
kbl() %>%
kable_styling(bootstrap_options = c("striped","hover")) %>%
scroll_box(width = "100%" ,height = "500px")
# Chunk 5
sum(is.na(dane))
# Chunk 6
dane %>%
ggplot(aes(x=Plec, fill=Plec)) +
geom_bar() +
labs(title = "Liczba badanych osób", y = "Liczba", x = "Płeć")+
scale_x_discrete(labels = c("F", "M"),
breaks = c("0", "1"))+
scale_fill_manual(values = c("0"="deeppink", "1"="dodgerblue"),labels=c("F","M")) +
geom_text(stat='count', aes(label=..count..), position=position_stack(vjust=0.5)) +
theme_bw()
# Chunk 7
dane %>%
group_by(Wiek) %>%
summarize(mean_chol = mean(Cholesterol, na.rm = TRUE)) %>%
ggplot(aes(x = Wiek, y = mean_chol, fill = mean_chol)) +
geom_bar(stat = "identity") +
labs(title = "Związek między wiekiem a poziomem cholesterolu", y = "Średni poziom cholesterolu", x = "Wiek") +
theme_bw() +
scale_fill_gradient(low="powderblue",high="firebrick")+
scale_x_continuous(breaks = seq(20, 80, 5))
# Chunk 8
chlg1 <- dane %>%
filter(Cholesterol < 200)%>%
summarise(Liczba_Osob=n())
chlg2 <- dane %>%
filter(Cholesterol > 200 & Cholesterol<250)%>%
summarise(Liczba_Osob=n())
chlg3 <- dane %>%
filter(Cholesterol > 250)%>%
summarise(Liczba_Osob=n())
chl <- data.frame(
grupa = c("Cholesterol ponizej 200","Cholesteror między 200 a 250","Cholesteror powyżej 250"),
Liczba_Osob = c(chlg1$Liczba_Osob, chlg2$Liczba_Osob,chlg3$Liczba_Osob)
)
ggplot(data = chl, aes(x = grupa, y = Liczba_Osob)) +
geom_col(fill=c("#E69F00", "#8B5547","#8B0000")) +
labs(title = "Poziom cholesterolu u pacjentów",
y = "Liczba osób", x = "") +
geom_text(aes(label = Liczba_Osob), position = position_dodge(width = 0.6),
vjust = -0.5)+
theme_bw()
# Chunk 9
dane %>%
group_by(ChorobaSerca) %>%
summarize(mean_wiek = mean(Wiek)) %>%
ggplot(aes(x=ChorobaSerca, y=mean_wiek, fill=factor(ChorobaSerca))) +
geom_col(position="dodge") +
geom_text(aes(label=round(mean_wiek,1)), position=position_dodge(width=0.9), vjust=-0.5) +
labs(title="Średni wiek pacjentów w zależności od obecności choroby serca",
x="Obecność choroby serca", y="Średni wiek") +
scale_x_discrete(labels = c("Brak", "Obecność"),
breaks = c("0", "1"))+
scale_fill_manual(values=c("#999999", "#E69F00"),labels=c("Brak","Obecność"),name="Choroba Serca") +
theme_bw()
# Chunk 10
ggplot(dane, aes(x=factor(Typ_bólu), y=Ciśnienie_krwi, fill=factor(Typ_bólu))) +
geom_boxplot() +
labs(title="Rozkład wartości ciśnienia krwi w zależności od typu bólu w klatce piersiowej",
x="Typ bólu w klatce piersiowej", y="Ciśnienie krwi") +
scale_fill_manual(values=c("#999999", "#E69F00", "#56B4E9", "#009E73")) +
theme_bw()
# Chunk 11
ggplot(dane, aes(x=Wiek, y=Tętno, color=factor(ChorobaSerca))) +
geom_point(alpha=0.5) +
labs(title="Związek między wiekiem a tętnem pacjentów",
x="Wiek (lata)", y="Tętno (uderzenia na minutę)", color="Obecność choroby serca") +
scale_color_manual(values=c("#999999", "#E69F00")) +
theme_bw()
# Chunk 12
set.seed(2023)
podzial <- initial_split(dane,prop=0.7,strata=ChorobaSerca)
trenowane <- training(podzial)
testowane <- testing(podzial)
vfold_cv(trenowane, v = 10,repeats = 5)
# Chunk 13
set.seed(2023)
mod.rpart <- rpart(ChorobaSerca~., data = trenowane,
control = rpart.control(minsplit = 10,
minbucket = 5,
maxdepth = 4))
summary(mod.rpart)
rpart.plot(mod.rpart)
pred.prob <- predict(mod.rpart,newdata=testowane)
pred.prob[10:20]
pred.class <- predict(mod.rpart, newdata = testowane, type = "class")
pred.class
tab <- table(predykcja = pred.class, obserwacja = testowane$ChorobaSerca)
tab
accdc <- sum(diag(tab)/sum(tab))
ggplot(data = as.data.frame(tab), aes(y = predykcja, x = obserwacja, fill = Freq)) +
geom_tile() +
geom_text(aes(label = Freq),size=10,color="black") +
scale_fill_gradient(low = "white", high = "red") +
labs(title = "Macierz Pomyłek",  x = "Prawdziwa klasa", y = "Przewidywana klasa") +
theme_bw()
# Tworzenie obiektu "prediction"
pred <- prediction(pred.prob[,2], testowane$ChorobaSerca)
# Obliczanie krzywej ROC i AUC
perf <- performance(pred, measure = "tpr", x.measure = "fpr")
AUC_ROC <- performance(pred, measure = "auc")@y.values[[1]]
# Tworzenie wykresu AUC-ROC
ggplot(data = data.frame(x = perf@x.values[[1]], y = perf@y.values[[1]]),
aes(x = x, y = y)) +
geom_line() +
labs(title = "Krzywa ROC", x = "Odsetek fałszywie pozytywnych",
y = "Odsetek prawdziwie pozytywnych")+
annotate("text", x = 0.5, y = 0.3, label = paste("AUC = ", round(AUC_ROC, 2)))+
theme_bw()
# Chunk 14
set.seed(2023)
# Regresja logistyczna
model_reglog <- glm(ChorobaSerca ~ ., data = trenowane, family = binomial())
# # Predict on test data
pred <- predict(model_reglog, newdata = testowane, type = "response")
# # Convert predictions to 0/1 based on a threshold
pred_binary <- ifelse(pred >= 0.5, 1, 0)
# Convert both predicted and actual variables to factors with same levels
pred_factor <- factor(pred_binary, levels = c(0, 1))
actual_factor <- factor(testowane$ChorobaSerca, levels = c(0, 1))
# Compute confusion matrix
tab <- table(pred_factor, actual_factor)
# utwórz macierz pomyłek
conf_mat <- table(pred_factor, actual_factor)
acclogreg <- sum(diag(conf_mat)/sum(conf_mat))
# przekonwertuj na ramkę danych
df <- as.data.frame.matrix(conf_mat)
df$pred_factor <- rownames(df)
df <- tidyr::pivot_longer(df, cols = c("0", "1"), names_to = "actual_factor", values_to = "freq")
# wyświetl macierz jako heatmap
ggplot(df, aes(x = actual_factor, y = pred_factor, fill = freq)) +
geom_tile(color = "white") +
geom_text(aes(label = freq),size=10,color="black") +
scale_fill_gradient(low = "white", high = "red") +
labs(x = "Prawdziwa klasa", y = "Przewidywana klasa", title = "Macierz Pomyłek") +
theme_bw()
# Przewidywanie prawdopodobieństwa dla zbioru testowanego
pred_log <- predict(model_reglog, newdata = testowane, type = "response")
# Oblicz wektor binarny na podstawie prawdopodobieństwa i progu 0.5
pred_binary <- prediction(pred_log, actual_factor)
# Oblicz AUC
perf_log <- performance(pred_binary, measure = "tpr", x.measure = "fpr")
auc <- unlist(performance(pred_binary, measure = "auc")@y.values)
# Wygeneruj wykres krzywej ROC
roc_curve <- performance(pred_binary, measure = "tpr", x.measure = "fpr")
ggplot() +
geom_line(data = data.frame(x = roc_curve@x.values[[1]], y = roc_curve@y.values[[1]]),
aes(x = x, y = y)) +
labs(title = "Krzywa ROC", x = "Odsetek fałszywie pozytywnych",
y = "Odsetek prawdziwie pozytywnych") +
annotate("text", x = 0.5, y = 0.3, label = paste("AUC = ", round(auc, 2)))+
theme_bw()
# Chunk 15
set.seed(2023)
acc <- function(pred, obs){
tab <- table(pred,obs)
acc <- sum(diag(prop.table(tab)))
acc
}
1:20 %>%
map(~knn3(ChorobaSerca~., data = trenowane, k = .x)) %>%
map(~predict(.x, newdata = testowane, type = "class")) %>%
map_dbl(~acc(pred = .x, obs = testowane$ChorobaSerca)) %>%
tibble(k = 1:length(.), acc=.) %>%
ggplot(aes(k, acc))+
geom_line()
# Chunk 16
set.seed(2023)
modelknn <- knn(trenowane,testowane,trenowane$ChorobaSerca,k=4)
macpom <- table(modelknn,testowane$ChorobaSerca)
knnacc <- sum(diag(macpom)/sum(macpom))
macpomdf <- as.data.frame(macpom)
ggplot(data = macpomdf, aes(y = modelknn, x = Var2, fill = Freq)) +
geom_tile() +
geom_text(aes(label = Freq),size=10,color="black") +
scale_fill_gradient(low = "white", high = "red") +
labs(title = "Macierz Pomyłek",  x = "Prawdziwa klasa", y = "Przewidywana klasa") +
theme_bw()
# Chunk 17
set.seed(2023)
modelknn25 <- knn(trenowane,testowane,trenowane$ChorobaSerca,k=8)
macpom25 <- table(modelknn25,testowane$ChorobaSerca)
knnacc25 <- sum(diag(macpom25)/sum(macpom25))
macpomdf25 <- as.data.frame(macpom25)
ggplot(data = macpomdf25, aes(y = modelknn25, x = Var2, fill = Freq)) +
geom_tile() +
geom_text(aes(label = Freq),size=10,color="black") +
scale_fill_gradient(low = "white", high = "red") +
labs(title = "Macierz Pomyłek",  x = "Prawdziwa klasa", y = "Przewidywana klasa") +
theme_bw()
# Chunk 18
set.seed(2023)
rf_spec <- rand_forest() %>%
set_mode("classification") %>%
set_engine("ranger") #ustawiamy silnik lasu losowego
rf_wf <- workflow() %>%
add_formula(ChorobaSerca ~ .) %>%
add_model(rf_spec)
rf_fit <- rf_wf %>%
fit(data = trenowane)
rf_results <- rf_fit %>%
predict(new_data = testowane)
conf_mat <- table(rf_results$.pred_class, testowane$ChorobaSerca)
rfacc <- sum(diag(conf_mat)/sum(conf_mat))
conf_table_long <- melt(conf_mat)
ggplot(data = conf_table_long, aes(y = Var.2, x = Var.1, fill = value)) +
geom_tile() +
geom_text(aes(label = value),size=10,color="black") +
scale_fill_gradient(low = "white", high = "red") +
labs(title = "Macierz Pomyłek",  x = "Prawdziwa klasa", y = "Przewidywana klasa") +
theme_bw()
rf_results1 <- rf_fit %>%
predict(new_data = testowane,type="prob")
pred_rf <- prediction(rf_results1$.pred_1,testowane$ChorobaSerca)
# Obliczanie krzywej ROC i AUC
perf_rf <- performance(pred_rf, measure = "tpr", x.measure = "fpr")
rocrf <- roc(testowane$ChorobaSerca,rf_results1$.pred_1)
rocrfdf <- data.frame(
specificity=rocrf$specificities,
sensitivity=rocrf$sensitivities
)
ggplot(data = rocrfdf, aes(x = 1 - specificity, y = sensitivity)) +
geom_line() +
annotate("text", x = 0.5, y = 0.3, label = paste("AUC = ", round(rocrf$auc, 2)))+
labs(title = "Krzywa ROC", x = "Odsetek fałszywie pozytywnych",
y = "Odsetek prawdziwie pozytywnych")+
theme_bw()
# Chunk 19
#Naiwne
# podział danych na zbiór treningowy i testowy
set.seed(2023)
# trening modelu Naive Bayes
model_nb <- naiveBayes(ChorobaSerca ~ ., data = trenowane)
# predykcja na danych testowych
predykcja_nb <- predict(model_nb, newdata = testowane)
# ocena jakości modelu
wyniki_nb <- table(predykcja_nb, testowane$ChorobaSerca)
accuracy_nb <- sum(diag(wyniki_nb))/sum(wyniki_nb)
df <- data.frame(
x = rep(colnames(tab), each = ncol(tab)),
y = rep(rownames(tab), ncol(tab)),
value = as.vector(tab)
)
# tworzenie heatmapy
ggplot(df, aes(x = x, y = y, fill = value)) +
geom_tile(color = "white") +
scale_fill_gradient(low = "white", high = "red") +
geom_text(aes(label = value),size=10, color = "black") +
labs(title = "Macierz pomyłek", x = "Prawdziwa klasa", y = "Przewidywana klasa")+
theme_bw()
# predykcja na danych testowych
predykcja_nb <- predict(model_nb, newdata = testowane, type = "raw")
# obliczenie miary AUC-ROC
auc_roc <- performance(prediction(predykcja_nb[, 2], testowane$ChorobaSerca), "auc")@y.values[[1]]
# krzywa ROC
pred_roc <- prediction(predykcja_nb[, 2], testowane$ChorobaSerca)
roc <- performance(pred_roc, "tpr", "fpr")
df_roc <- data.frame(x = roc@x.values[[1]], y = roc@y.values[[1]])
ggplot(df_roc, aes(x, y)) +
geom_line() +
annotate("text", x = 0.5, y = 0.3, label = paste("AUC = ", round(auc_roc, 2)))+
labs(title = "Krzywa ROC", x = "Odsetek fałszywie pozytywnych",
y = "Odsetek prawdziwie pozytywnych")+
theme_bw()
# Chunk 20
# podział danych na zbiór treningowy i testowy
set.seed(2023)
# trening modelu LDA
model_lda <- lda(ChorobaSerca ~ ., data = trenowane)
# predykcja na danych testowych
predykcja_lda <- predict(model_lda, newdata = testowane)
# ocena jakości modelu
wyniki_lda <- table(predykcja_lda$class, testowane$ChorobaSerca)
accuracy_lda <- sum(diag(wyniki_lda))/sum(wyniki_lda)
# zmiana formatu wyników na data.frame
wyniki_lda_df <- as.data.frame(wyniki_lda)
# nazwanie kolumn
colnames(wyniki_lda_df) <- c("Predykcja", "Prawdziwe","Freq")
# zmiana typu danych na czynnik
wyniki_lda_df$Predykcja <- as.factor(wyniki_lda_df$Predykcja)
wyniki_lda_df$Prawdziwe <- as.factor(wyniki_lda_df$Prawdziwe)
# stworzenie macierzy konfuzji
macierz_konfuzji <- matrix(c(wyniki_lda_df[1,2], wyniki_lda_df[2,2], wyniki_lda_df[1,1], wyniki_lda_df[2,1]), nrow = 2)
# tworzenie heatmapy
ggplot(data = wyniki_lda_df, aes(x = Prawdziwe, y = Predykcja, fill = Freq)) +
geom_tile() +
scale_fill_gradient(low = "white", high = "red") +
geom_text(aes(label = Freq), size=10,color = "black") +
labs(x = "Prawdziwa klasa", y = "Przewidywana klasa",title="Macierz Pomyłek") +
theme_bw()
# obliczenie miary AUC-ROC
pred_lda <- prediction(predykcja_lda$posterior[,2], testowane$ChorobaSerca)
auc_lda <- as.numeric(performance(pred_lda, "auc")@y.values)
# wykres krzywej ROC
perf_lda <- performance(pred_lda, measure = "tpr", x.measure = "fpr")
ggplot(data = data.frame(x = roc@x.values[[1]], y = roc@y.values[[1]]), aes(x = x, y = y)) +
geom_line() +
annotate("text", x = 0.5, y = 0.3, label = paste("AUC = ", round(auc_lda, 2)))+
labs(title = "Krzywa ROC", x = "Odsetek fałszywie pozytywnych",
y = "Odsetek prawdziwie pozytywnych")+
theme_bw()
# Chunk 21
set.seed(2023)
svmModel <- svm(ChorobaSerca~.,data=trenowane)
svmPredykcja <- predict(svmModel,testowane[,-14])
svmAccuracy <- mean(svmPredykcja==testowane[,14])
trueLabels <- testowane[, 14]
confusionMatrix <- table(svmPredykcja, trueLabels)
confmatdf <- as.data.frame(confusionMatrix)
ggplot(data = confmatdf, aes(y = svmPredykcja, x = trueLabels, fill = Freq)) +
geom_tile() +
scale_fill_gradient(low = "white", high = "red") +
geom_text(aes(label = Freq), size=10,color = "black") +
labs(x = "Prawdziwa klasa", y = "Przewidywana klasa",title="Macierz Pomyłek") +
theme_bw()
roc_obj <- roc(as.numeric(svmPredykcja),as.numeric(trueLabels))
rocdf <- data.frame(
specificity=roc_obj$specificities,
sensitivity=roc_obj$sensitivities
)
ggplot(data = rocdf, aes(x = 1 - specificity, y = sensitivity)) +
geom_line() +
annotate("text", x = 0.5, y = 0.3, label = paste("AUC = ", round(roc_obj$auc, 2)))+
labs(title = "Krzywa ROC", x = "Odsetek fałszywie pozytywnych",
y = "Odsetek prawdziwie pozytywnych")+
theme_bw()
# Chunk 22
# library(neuralnet)
# library(NeuralNetTools)
# set.seed(2023)
#
# dane$Plec <- as.numeric(dane$Plec)
# dane$Typ_bólu <- as.numeric(dane$Typ_bólu)
# dane$Wynik_EKG <- as.numeric(dane$Wynik_EKG)
# dane$Dławica_Piersiowa <- as.numeric(dane$Dławica_Piersiowa)
# dane$nachylenie <- as.numeric(dane$nachylenie)
# dane$defekt <- as.numeric(dane$defekt)
#
# podzial <- initial_split(dane,prop=0.7,strata=ChorobaSerca)
# trenowane <- training(podzial)
# testowane <- testing(podzial)
#
# model_neur <- neuralnet(ChorobaSerca~ ., data=trenowane,hidden=c(10,4),
#                     linear.output = FALSE,err.fct = "ce",stepmax=1000000)
# plot(model_neur,rep="best")
#
# pred1 <- predict(model_neur,testowane)
# labels1 <- c("0","1")
# prediction_label1 <- data.frame(max.col(pred1))%>%
#   mutate(pred1=labels1[max.col.pred1.])
#
#
# table(testowane$ChorobaSerca,prediction_label1)
#
# check1=as.numeric(testowane$ChorobaSerca)==max.col(pred1)
# accuracy1=(sum(check1)/nrow(testowane))
# print(accuracy1)
fig.dim=c(30,20)
plot(perf,col="blue")
plot(perf_log,add=TRUE,col="green")
plot(perf_rf,add=TRUE,col="red")
plot(roc,add=TRUE,col="orange")
plot(perf_lda,add=TRUE,col="purple")
legend("topright",legend = c(paste("Random forest: ",round(rocrf$auc,2)),
paste("Logistic regression: ",round(auc,2)),
paste("Naive Bayes :",round(auc_roc,2)),paste("Decision tree:", round(AUC_ROC,2)),
paste("Linear discriminant analysis: ",round(auc_lda,2))),
col=c("red","green","orange","blue","purple"),lwd=3,cex=0.6)
fig.dim=c(30,20)
plot(perf,col="blue")
plot(perf_log,add=TRUE,col="green")
plot(perf_rf,add=TRUE,col="red")
plot(roc,add=TRUE,col="orange")
plot(perf_lda,add=TRUE,col="purple")
legend("topright",legend = c(paste("Random forest: ",round(rocrf$auc,2)),
paste("Linear discriminant analysis: ",round(auc_lda,2)),
paste("Logistic regression: ",round(auc,2)),
paste("Naive Bayes :",round(auc_roc,2)),paste("Decision tree:", round(AUC_ROC,2)),
),
col=c("red","green","orange","blue","purple"),lwd=3,cex=0.6)
fig.dim=c(30,20)
plot(perf,col="blue")
plot(perf_log,add=TRUE,col="green")
plot(perf_rf,add=TRUE,col="red")
plot(roc,add=TRUE,col="orange")
plot(perf_lda,add=TRUE,col="purple")
legend("topright",legend = c(paste("Random forest: ",round(rocrf$auc,2)),
paste("Linear discriminant analysis: ",round(auc_lda,2)),
paste("Logistic regression: ",round(auc,2)),
paste("Naive Bayes :",round(auc_roc,2)),
paste("Decision tree:", round(AUC_ROC,2)),
),
col=c("red","green","orange","blue","purple"),lwd=3,cex=0.6)
fig.dim=c(30,20)
plot(perf,col="blue")
plot(perf_log,add=TRUE,col="green")
plot(perf_rf,add=TRUE,col="red")
plot(roc,add=TRUE,col="orange")
plot(perf_lda,add=TRUE,col="purple")
legend("topright",legend = c(paste("Random forest: ",round(rocrf$auc,2)),
paste("Linear discriminant analysis: ",round(auc_lda,2)),
paste("Logistic regression: ",round(auc,2)),
paste("Naive Bayes :",round(auc_roc,2)),
paste("Decision tree:", round(AUC_ROC,2))
),
col=c("red","green","orange","blue","purple"),lwd=3,cex=0.6)
fig.dim=c(30,20)
plot(perf,col="blue")
plot(perf_log,add=TRUE,col="green")
plot(perf_rf,add=TRUE,col="red")
plot(roc,add=TRUE,col="orange")
plot(perf_lda,add=TRUE,col="purple")
legend("topright",legend = c(paste("Random forest: ",round(rocrf$auc,2)),
paste("Linear discriminant analysis: ",round(auc_lda,2)),
paste("Logistic regression: ",round(auc,2)),
paste("Naive Bayes :",round(auc_roc,2)),
paste("Decision tree:", round(AUC_ROC,2))
),
col=c("red","green","orange","blue","purple"),lwd=3,cex=0.6)
fig.dim=c(30,20)
plot(perf,col="red")
plot(perf_log,add=TRUE,col="green")
plot(perf_rf,add=TRUE,col="orange")
plot(roc,add=TRUE,col="blue")
plot(perf_lda,add=TRUE,col="purple")
legend("topright",legend = c(paste("Random forest: ",round(rocrf$auc,2)),
paste("Linear discriminant analysis: ",round(auc_lda,2)),
paste("Logistic regression: ",round(auc,2)),
paste("Naive Bayes :",round(auc_roc,2)),
paste("Decision tree:", round(AUC_ROC,2))
),
col=c("red","green","orange","blue","purple"),lwd=3,cex=0.6)
fig.dim=c(30,20)
plot(perf_rf,col="red")
plot(perf_lda,add=TRUE,col="green")
plot(perf_log,add=TRUE,col="orange")
plot(roc,add=TRUE,col="blue")
plot(perf,add=TRUE,col="purple")
legend("topright",legend = c(paste("Random forest: ",round(rocrf$auc,2)),
paste("Linear discriminant analysis: ",round(auc_lda,2)),
paste("Logistic regression: ",round(auc,2)),
paste("Naive Bayes :",round(auc_roc,2)),
paste("Decision tree:", round(AUC_ROC,2))
),
col=c("red","green","orange","blue","purple"),lwd=3,cex=0.6)
